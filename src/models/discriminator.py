import torch
import torch.nn as nn
import torch.nn.utils.spectral_norm as spectral_norm

class PatchDiscriminator(nn.Module):
    """
    PatchGAN Discriminator with Spectral Normalization.
    
    Designed to differentiate between real noisy spectrograms and 
    synthetic noisy spectrograms generated by SimuGAN.
    
    Returns:
      logits (torch.Tensor): The final classification map [Batch, 1, H, W]
      feats (list[torch.Tensor]): Intermediate feature maps for Feature Matching Loss.
    """
    def __init__(self, base_ch: int = 64):
        super().__init__()

        def spectral_conv(in_ch, out_ch, k, s, p):
            """Helper to apply Spectral Normalization to Conv2d."""
            return spectral_norm(nn.Conv2d(in_ch, out_ch, k, s, p))

        # Layer 1: [B, 1, F, T] -> [B, 64, F/2, T/2]
        self.layer1 = nn.Sequential(
            spectral_conv(1, base_ch, 4, 2, 1),
            nn.LeakyReLU(0.2, True),
        )

        # Layer 2: [B, 64, ...] -> [B, 128, ...]
        self.layer2 = nn.Sequential(
            spectral_conv(base_ch, base_ch * 2, 4, 2, 1),
            nn.InstanceNorm2d(base_ch * 2),
            nn.LeakyReLU(0.2, True),
        )

        # Layer 3: [B, 128, ...] -> [B, 256, ...]
        self.layer3 = nn.Sequential(
            spectral_conv(base_ch * 2, base_ch * 4, 4, 2, 1),
            nn.InstanceNorm2d(base_ch * 4),
            nn.LeakyReLU(0.2, True),
        )

        # Final Layer: Output 1 channel (Real/Fake map)
        self.final = spectral_conv(base_ch * 4, 1, 4, 1, 1)

    def forward(self, x: torch.Tensor):
        feats = []
        
        # Pass through layers and collect intermediate features
        h = self.layer1(x)
        feats.append(h)
        
        h = self.layer2(h)
        feats.append(h)
        
        h = self.layer3(h)
        feats.append(h)
        
        # Final classification
        out = self.final(h)
        
        return out, feats